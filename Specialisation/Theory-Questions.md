1.1 Collections library

1.2 A tree can be acyclic, meaning it does not contain any loops and there is only one path between two nodes in a tree. Whereas, a graph can be acyclic or cyclic, therefore, there can be cycles and loops so a sequences of edges can return you to a node you have visited before. Moreover, a tree has a rooted data structure, therefore, it has a root node which are followed by edges. Whereas, a graph does not need a root or starting node.

1.3 Time complexity is a measure of how long it takes for an algorithm to run and how the run time will increase in relation to the size of the input. Space complexity is a measure of much space or memory an algorithm requires to complete its task, also considering the input of the function.

1.4 A sorting algorithm that repeats its steps by comparing neighbouring elements and swapping them if they are out of order. This will be done until the entire list is sorted and elements bubble to the top of the list. Bubble sorts have a time complexity of O(n^2), with n being the number of elements in the list. Bubble sorts are not efficient for large lists. In terms of space complexity, bubble sorts are O(1), as the list is sorted without requiring additional memory. At the end of the first pass, the largest element in the list will have bubbled to the correct place.

1.5 LIFO (Last in, First out) is a data structure where the last item added to a collection is the first one to be removed from that collection. A stack is a data structure that implements LIFO, where a collection of elements can be added to the top of the stack and items can be popped from the top of the stack. FIFO (First in, First out) is an organisation method where the first item added to a collection is also the first one to be removed. A data structure that uses FIFO is a queue. Items are enqueued to the back of the queue and dequeued from the front.

1.6 A balanced binary tree is a tree where the height of the left and right subtree of the nodes are not different by 1. Therefore, the height difference can only be 1, 0 or -1, which enables the tree to stay balanced. A balanced binary tree allows for efficient searching, inserting and deletion operations. The best root would be one that devides the data into equal havles to create a balanced structure, therefore, the root would have to be the median value from the list. Using search would be efficient. One would start at the node, compare the searching value with the value of the current node and if the node matches then the search stops. If not, and the searching value is smaller than the current node value, then you would move to the left child node. If the searching value is larger than the current node value, then you would move to the right child node. These steps will be repeated until the value is found, or until a leaf node- a node with no children - is reached.
